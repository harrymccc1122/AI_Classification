import tkinter as tk
from tkinter import filedialog
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

from matplotlib.lines import Line2D

from classifier import classify_data


def show_ui():
    """Creates main window"""
    window = tk.Tk()
    window.title("Walking / Jumping AI")  # Add a window title
    window.geometry("700x500")  # Set the window size to 800x600 pixels
    window.minsize(700, 500)

    # Prepare main frame and frame for buttons
    button_frame = tk.Frame(window, width=150, background="gray")
    button_frame.pack(side=tk.LEFT, fill=tk.Y)
    main_frame = tk.Frame(window)
    main_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

    # show greeting (jumpGPT is a joke the message was not generated by AI)
    greeting_text = 'Welcome to JumpGPT! Click "Upload File" with a CSV file to tell if you were jumping or walking'
    greeting = tk.Label(main_frame, text=greeting_text)
    greeting.pack()

    # add upload and save buttons
    upload_button = tk.Button(button_frame, text="Upload File", width=10, command=lambda: upload(main_frame))
    upload_button.pack(padx=10, pady=10)
    save_as_button = tk.Button(button_frame, text="Save As", width=10, command=save)
    save_as_button.pack(padx=10, pady=10)

    window.mainloop()


def save():
    # don't do anything if there is no data to save
    if current_data_file_path == "":
        return

    # get user input of where to place the output file
    file_path = filedialog.asksaveasfilename(defaultextension='.csv', filetypes=[("Comma Separated Value", ".csv")])
    classified_data = classify_data("data.h5", current_data_file_path)
    # save output of classifier to disk
    classified_data.to_csv(file_path)


def upload(parent):
    global current_data_file_path
    global canvas_widget
    # get the path of the csv from the data
    current_data_file_path = filedialog.askopenfilename(filetypes=[("Comma Separated Value", ".csv")])
    # classify the input data
    classified_data = classify_data("data.h5", current_data_file_path)

    # remove the plot from the window if there is already a plot
    if canvas_widget is not None:
        canvas_widget.destroy()

    # create plot
    fig = Figure(figsize=(5, 4), dpi=100)
    ax = fig.add_subplot(1, 1, 1)

    # prepare data to be plotted
    colors = {
        None: "gray",
        0: "red",  # jumping
        1: "green",  # walking
    }

    # this section below is complicated
    # it takes the input classified data and creates a list of lines to draw
    # every time the color of the line changes (the data is labeled from jumping to walking or vice versa)
    # a new line needs to be drawn

    # this is to avoid having the sections with jumping from being overlaid on top the walking line and vice versa

    transition_indices = [
        i+1 for i in range(0, len(classified_data)-1)
        if classified_data.iloc[i, -1] != classified_data.iloc[i+1, -1]
    ]
    # add 0 as the start of the line to make the slice for loop work
    transition_indices = [0] + transition_indices

    # draw each section by taking a slice of the input dataframe
    for i in range(0, len(transition_indices)-1):
        category_data = classified_data.iloc[transition_indices[i]:transition_indices[i+1]]
        category = category_data["category"].max()
        ax.plot(
            category_data["Time (s)"],
            category_data["Absolute acceleration (m/s^2)"],
            color=colors[category],
        )

    # because there are multiple lines that represent jumping and walking, the default legend behavior
    # would display one legend per segment

    # use this hack to force the legend to show one label for jumping and one label for walking
    ax.legend(handles=[
        Line2D([0], [0], color='r', label="Jumping"),
        Line2D([0], [0], color='g', label="Walking"),
    ])

    ax.set_xlabel("Time (s)")
    ax.set_ylabel("Absolute Acceleration (m/s^2)")

    # display the plot on the app
    canvas = FigureCanvasTkAgg(fig, master=parent)  # Embedding in the parent frame
    canvas.draw()
    canvas_widget = canvas.get_tk_widget()
    canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)


def main():
    show_ui()


if __name__ == "__main__":
    # these variables need to be global scope
    current_data_file_path = ""
    canvas_widget = None
    main()
